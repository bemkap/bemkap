\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage{indentfirst}
\title{{\textbf{\Large{Trabajo Práctico}\\Mini VM}}}
\author{Rossi, Martín. Legajo 9901/8}
\date{Febrero 2018}
\begin{document}
\maketitle
\section*{Resumen}
\indent El programa está compuesto por tres partes, el lexer o analizador léxico (flex), el parser o analizador sintáctico (bison) y el programa que simula la máquina.\par Lo primero que se ejecuta es el lexer que toma como entrada el nombre de un archivo, lo lee y lo separa en tokens. Ésto está definido en el archivo $parser.lex$. Un token puede ser una cadena fija, como por ejemplo la palabra $call$, o un conjunto de cadenas, y para ello se usan expresiones regulares, como por ejemplo \verb+"\$"DIGIT+ donde \verb+DIGIT+ se define como \verb+[0-9]\++.\par Luego se ejecuta el parser, que toma los tokens como entrada y a partir de una gramática libre de contexto forma la estructura de árbol correspondiente a la cadena que define la gramática. En el archivo $parser.y$ se definen los tokens que serán la entrada y las reglas, así como un código que se ejecutará cuando se apliquen. En este caso cuando se aplica la regla para el no terminal \verb+input+ se guarda en el arreglo \verb+code+ una estructura que representa a una instrucción.\par Finalmente se ejecuta el programa principal que va leyendo el código y modifica el estado de la máquina virtual, o sea, los registros y la memoria.
\section*{Posibles extensiones}
\begin{itemize}
\item Agregar secciones data y text, e instrucciones para reservar espacio para números o texto.
\item Agregar instrucciones más complejas de x86.
\item Agregar más registros, y simular la unidad de punto flotante.
\item Usar más bits del registro FLAGS, para simular las banderas CARRY, OVERFLOW, ZERO, etc.
\item Agregar comentarios al lenguaje de la máquina virtual.
\end{itemize}
\section*{Problemas}
\begin{enumerate}
\item Encontrar una forma concisa de escribir los casos de cada instrucción, sean memoria, registro o inmediato.
\item Los registros son int y la memoria es char.
\item Al agregar call y ret el programa no necesariamente inicia en la primera instrucción del código.
\item Las instrucciones jump y call no incrementan el program counter.
\end{enumerate}
\section*{Soluciones}
\begin{enumerate}
\item Elegir con un array indexado por el tipo de operando.
\item La memoria se maneja manualmente como arreglo de ints.
\item Empezar por la etiqueta main. Cuando se procesan las etiquetas se guarda la ubicación de main y se empieza por ahí. Si no existe main empieza por el principio del código.
\item Cuando se ejecuta una de esas instrucciones restar 1 al program counter.  
\end{enumerate}
\section*{Tests}
\subsection*{Test 1: Valor absoluto (test1.asm)}
\subsubsection*{Representación en C++:}
\begin{verbatim}
Instruction code[]={
  Instruction(LABEL,Operand("main",LABELOP)),
  Instruction(READ,Operand(REG,R0)),
  Instruction(CMP,Operand(REG,R0),Operand(IMM,0)),
  Instruction(JMPL,Operand("prnt",LABELOP)),
  Instruction(MUL,Operand(IMM,-1),Operand(REG,R0)),
  Instruction(LABEL,Operand("prnt",LABELOP)),
  Instruction(PRINT,Operand(REG,R0)),
  Instruction(HLT)
}
\end{verbatim}
\subsubsection*{Explicación:}
El programa lee el número, si es menor a cero lo multiplica por -1, sino salta la instrucción de multiplicación y finalmente se muestra por pantalla.
\subsection*{Test 2: Contador de bits (test2.asm)}
\subsubsection*{Representación en C++:}
\begin{verbatim}
Instruction code[]={
  Instruction(LABEL,Operand("main",LABELOP)),
  Instruction(MOV,Operand(IMM,0),Operand(REG,R0)),
  Instruction(LABEL,Operand("loop",LABELOP)),
  Instruction(MOV,Operand(REG,R1),Operand(REG,R2)),
  Instruction(SUB,Operand(IMM,1),Operand(REG,R2)),
  Instruction(AND,Operand(REG,R2),Operand(REG,R1)),
  Instruction(ADD,Operand(IMM,1),Operand(REG,R0)),
  Instruction(CMP,Operand(REG,R1),Operand(IMM,0)),
  Instruction(JMPL,Operand("loop",LABELOP)),
  Instruction(PRINT,Operand(REG,R0)),
  Instruction(HLT)
}
\end{verbatim}
\subsubsection*{Explicación}
Dado un entero \verb+n+, \verb+n&(n-1)+ apaga el bit más significativo. El programa lee un número en \verb+r1+, y hace \verb+r1=r1&(r1-1)+ hasta que sea 0, agregando 1 en el registro \verb+r0+ cada vez. Al final imprime \verb+r0+.
\subsection*{Test 3: Suma de arreglo (test3.asm)}
\subsubsection*{Representación en C++:}
\begin{verbatim}
Instruction code[]={
  Instruction(LABEL,Operand("sum",LABELOP)),
  Instruction(MOV,Operand(IMM,0),Operand(REG,R0)),
  Instruction(ADD,Operand(IMM,4),Operand(REG,SP)),
  Instruction(LW,Operand(REG,SP),Operand(REG,R2)),
  Instruction(ADD,Operand(IMM,4),Operand(REG,SP)),
  Instruction(LW,Operand(REG,SP),Operand(REG,R1)),
  Instruction(SUB,Operand(IMM,8),Operand(REG,SP)),
  Instruction(LABEL,Operand("loop",LABELOP)),
  Instruction(LW,Operand(REG,R1),Operand(REG,R3)),
  Instruction(ADD,Operand(REG,R3),Operand(REG,R0)),
  Instruction(ADD,Operand(IMM,4),Operand(REG,R1)),
  Instruction(SUB,Operand(IMM,1),Operand(REG,R2)),
  Instruction(CMP,Operand(REG,R2),Operand(IMM,0)),
  Instruction(JMPL,Operand("loop",LABELOP)),
  Instruction(PRINT,Operand(REG,R0)),
  Instruction(RETURN),
  Instruction(LABEL,Operand("main",LABELOP)),
  Instruction(SW,Operand(IMM,4),Operand(IMM,0)),
  Instruction(SW,Operand(IMM,5),Operand(IMM,4)),
  Instruction(SW,Operand(IMM,6),Operand(IMM,8)),
  Instruction(SW,Operand(IMM,7),Operand(IMM,12)),
  Instruction(PUSH,Operand(IMM,0)),
  Instruction(PUSH,Operand(IMM,4)),
  Instruction(CALL,Operand("sum",LABELOP)),
  Instruction(HLT)
}
\end{verbatim}
\subsubsection*{Explicación}
Primero se cargan números a la memoria simulando un arreglo, en este caso 4, 5, 6, 7 en las ubicaciones 0, 4, 8, 12. Ésto se hace con la instrucción \verb+SW+. Después se hace push de el inicio del arreglo, 0, el tamaño, 4, y se llama a la función \verb+sum+. \verb+sum+ primero pone en 0 a \verb+r0+, y copia los argumentos (arreglo y tamaño) en \verb+r1+ y \verb+r2+. A partir de \verb+loop+ se suma a \verb+r0+ el número apuntado por \verb+r1+ y se resta en 1 \verb+r2+. Se repite hasta que \verb+r2+ sea 0, quedando en \verb+r0+ la suma, que luego muestra por pantalla.
\end{document}